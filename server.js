const express = require('express');
const crypto = require('crypto');
const mkdirp = require('mkdirp');
const morgan = require('morgan');
const sharp = require('sharp');
const path = require('path');
const url = require('url');
const fs = require('fs');

const LargeObjectManager = require('pg-large-object').LargeObjectManager;
const Promise = require('bluebird');
const pgp = require('pg-promise')({ promiseLib: Promise });

Promise.promisifyAll(LargeObjectManager.prototype, {multiArgs: true});

const clientAdapter = t => ({
  query: (obj, callback) => t.query(obj).then(rows => ({rows})).asCallback(callback)
});

if (typeof process.env.DATABASE_URL === 'undefined') {
  throw new ReferenceError('DATABASE_URL environment variable must be set');
}
const db = pgp(process.env.DATABASE_URL);

const chargeImage = function(token, length) {
  const sql = 'UPDATE users SET balance = balance - $1 FROM pictures WHERE token = $2 AND users.id = pictures.user_id';
  db.none(sql, [length, token]).catch(function(err) {
    console.error('Error updating user balance', err);
  });
};

const app = express();

app.use(morgan('combined'))

const cacheDir = process.env.CACHE_DIR || 'tmp';

app.param('filename', function(req, res, next) {
  req.image = path.join(
    cacheDir,
    req.params.model,
    req.params.attribute,
    req.params.id,
    req.params.filename
  );

  next();
});

const oidQuery = function(params) {
  switch (params.model + '_' + params.attribute) {
  case 'picture_image':
    return 'SELECT image AS oid FROM pictures WHERE token = $1 AND image_filename = $2';
  case 'user_avatar':
    return 'SELECT avatar AS oid FROM users WHERE username = $1 AND avatar_filename = $2';
  }
}

const cacheFile = function(req, res, next) {
  const dest = req.image;

  fs.stat(dest, function(err, stats) {
    if (stats) {
      return next();
    }

    mkdirp(path.dirname(dest), function(err) {
      if (err) {
        return next(err);
      }

      const sql = oidQuery(req.params);

      db.one(sql, [req.params.id, req.params.filename]).then(function(data) {
        const oid = data.oid;

        db.tx(function(t) {
          const man = new LargeObjectManager(clientAdapter(t));

          return man.openAndReadableStreamAsync(oid).then(function([size, stream]) {
            const rand = crypto.randomBytes(24).toString('hex');
            const temp = fs.createWriteStream(dest + rand);

            stream.pipe(temp);

            return new Promise(function(resolve) {
              stream.on('end', function() {
                fs.link(dest + rand, dest, function(err) {
                  resolve();
                });
              });
            });
          });
        }).then(next).catch(next);

      }).catch(next);
    });
  });
};

// TODO: cache the files generated by this method
app.get('/:model/:attribute/:id/:geometry/:filename', cacheFile, function(req, res, next) {
  var geometry = req.params.geometry;
  var crop = false;

  if (geometry.slice(-1) == '!') {
    geometry = geometry.slice(0, -1);
    crop = true;
  }

  const dimensions = geometry.split('x');
  const width = Number(dimensions[0]) || null;
  const height = Number(dimensions[1]) || null;

  var resizer = sharp(req.image).resize(width, height);

  if (!crop) {
    resizer = resizer.max()
  }

  resizer
    .sharpen()
    .jpeg({ quality: 90 })
    .toBuffer(function(err, data, info) {
      if (err) {
        console.error('error resizing image ' + req.image, err);
        return next(err);
      }

      res.image = data;
      res.image.format = info.format;
      next();
    })
});

app.get('/:model/:attribute/:id/:filename', cacheFile, function(req, res, next) {
  fs.readFile(req.image, function(err, data) {
    if (err) {
      next(err);
      return console.error('error reading image ' + req.image, err);
    }

    res.image = data;
    res.image.format = 'image/jpeg';
    next();
  })
})

app.use('/:model/:attribute/:id', function(req, res, next) {
  if (res.image) {
    res.setHeader('Content-Type',   res.image.format);
    res.setHeader('Content-Length', res.image.length);
    res.send(res.image);

    if (req.params.model == 'picture') {
      chargeImage(req.params.id, res.image.length);
    }
  } else {
    next();
  }
});

app.use(express.static('public'));

const errorPage = fs.readFileSync(path.join(__dirname, 'public/index.html'));

app.use(function(req, res) {
  res.writeHead(404, { 'Content-Type': 'text/html' });
  res.write(errorPage);
  res.end();
});

app.use(function(err, req, res, next) {
  // FIXME: should be 500?
  res.writeHead(404, { 'Content-Type': 'text/html' });
  res.write(errorPage);
  res.end();
});

app.listen(process.env.PORT || '3000', function() {
  //console.log('Serving');
})
